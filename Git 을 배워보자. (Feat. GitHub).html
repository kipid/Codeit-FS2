<!DOCTYPE html>

<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=3, user-scalable=yes"/>

<codeprint id="docuK-style">
<div class="docuK rendered"><div class="sec" id="docuK-log"></div></div>

<!-- From kipid.tistory CDN -->
<script src="https://tistory1.daumcdn.net/tistory/1468360/skin/images/jquery.js"></script>
<link rel="stylesheet" href="https://tistory1.daumcdn.net/tistory/1468360/skin/images/docuK-2.3.css">
<script src="https://tistory3.daumcdn.net/tistory/1468360/skin/images/docuK-prepare-2.3.js" charset="utf-8"></script>
</codeprint><!-- docuK-style -->

<meta charset="utf-8" name="description" content="pure SEE."/>

<codeprint class="SEE">
# Git 을 배워보자. (Feat. GitHub)

버전 관리와 협업에 필수인 Git (and GitHub) 에 대해 배워봅시다.



## PH

<ul>
<li>2024-07-30 : First posting.</li>
</ul>



## TOC



## Git 설치 및 간단한 명령어들

Git 은 (Global Information Tracker) 의 약자로 대충 보면 된다. (처음 이름 지은 사람은 이런 의도를 가진 약자가 아니었던 같긴 한데... 저 표현이 Git 을 잘 나타내준다고 본다.)

우선 설치: <cite class="ref-git-download"></cite> 에서 다운 받고 대충 설치.

```
git init // 버전 관리 시작하기

git config user.name "kipid"
git config user.email "my-email@google.com"

git add calculator.py
git add License
git commit -m "Create calculator.py and License" // commit message (-m)

git status // 현재 상태 보기

git add . // 모든 파일 staging area 로 추가하기

git reset calculator.py // staging area 에서 제거하기

git reset . // 모든 파일 staging area 에서 제거



git help add // Manual 보기
```/

Git은 내부적으로 크게 3가지 종류의 작업 영역을 두고 동작

<ol>
<li>첫 번째 작업 영역인 working directory는 작업을 하는 프로젝트 디렉토리를 말합니다. 그러니까 지금 상황에서는 MathTool 디렉토리가 working directory입니다.</li>
<li>두 번째 작업 영역인 staging area는 git add를 한 파일들이 존재하는 영역입니다. 커밋을 하게되면 staging area에 있는 파일들만 커밋에 반영됩니다.</li>
<li>세 번째 작업 영역인 repository는 working directory의 변경 이력들이 저장되어 있는 영역입니다. 그러니까 커밋들이 저장되는 영역이라는 뜻인데요. 조금 풀어서 설명해볼게요.</li>
</ol>

<figure><div class="fig">
	<div class="caption">새로 생성되거나 편집된 파일을 체크해 줌으로서 git add 효과를 냄. Git -m (message) 도 "Create: Git 을 배워보자" 로 git commit. (Description 은 좀 더 구체적으로 설명을 붙이고 싶을때 쓰임.)</div>
	<img src="https://blog.kakaocdn.net/dn/PoM43/btsIQy7Oacl/bPtCWt6cN5FQelMEndIj6K/img.png">
</div></figure>

<figure><div class="fig">
	<div class="caption">git push 할 준비가 됨. Push origin 으로 외부서버인 GitHub 에 해당 버전의 commit 을 push.</div>
	<img src="https://blog.kakaocdn.net/dn/bQeLB5/btsISfzhFlE/mN5I1ci2t24zam7fR34s6k/img.png">
</div></figure>

<figure><div class="fig">
	<div class="caption">git pushed. GitHub 에 새로운 버전의 commit 이 있었다면 git fetch origin 으로 다운. 새 이미지를 저장해서 git-push.png 가 staging 된 것을 볼 수 있음.</div>
	<img src="https://blog.kakaocdn.net/dn/bzvyxr/btsIP6cPg19/K7WkBcqXmxOkkuIufKKsn1/img.png">
</div></figure>

<figure><div class="fig">
	<div class="caption">Git history 탭에서 그동안 commit 한 git 들을 모아볼 수 있음. 이건 나 혼자써서 branch 가 main 으로 하나지만 협업을 할 때는 branch 가 여러개가 되고 git merge 가 되는 등의 작업이 일어날 수 있음.</div>
	<img src="https://blog.kakaocdn.net/dn/cAcEOl/btsIRLL6bKV/N56RDix1eNKOu5EWp5m8Ok/img.png">
</div></figure>

이렇게 GUI (Graphical User Interface) 를 써서 git 을 다루는게 (GitHub 와 같이) 더 배우기도 쉽고 편하긴 한데... 굳이 git command 들을 외우고 Command Line Interface (CLI) 에서 작업해야 하는가가 의문이긴 함. 뭐 여러 복잡스런 작업들은 git command 로만 가능하거나 GUI 로는 더 복잡스러울수도 있을거 같긴 한데... 그럴일이 그렇게 많을거 같지도 않아서...

우선은 수업이 있으니 배워놓긴 할 예정. 안써서 금방 까먹을거 같긴 하지만...



## Git commands 정리

<div class="bcf">

git init : 현재 디렉토리를 Git이 관리하는 프로젝트 디렉토리(=working directory)로 설정하고 그 안에 레포지토리(.git 디렉토리) 생성

git config user.name 'codeit' : 현재 사용자의 아이디를 'codeit'으로 설정(커밋할 때 필요한 정보)

git config user.email 'teacher@codeit.kr' : 현재 사용자의 이메일 주소를 'teacher@codeit.kr'로 설정(커밋할 때 필요한 정보)

git add [파일 이름] : 수정사항이 있는 특정 파일을 staging area에 올리기

git add [디렉토리명] : 해당 디렉토리 내에서 수정사항이 있는 모든 파일들을 staging area에 올리기

git add . : working directory 내의 수정사항이 있는 모든 파일들을 staging area에 올리기

git reset [파일 이름] : staging area에 올렸던 파일 다시 내리기

git status : Git이 현재 인식하고 있는 프로젝트 관련 내용들 출력(문제 상황이 발생했을 때 현재 상태를 파악하기 위해 활용하면 좋음)

git commit -m "커밋 메시지" : 현재 staging area에 있는 것들 커밋으로 남기기

git help [커맨드 이름] : 사용법이 궁금한 Git 커맨드의 공식 메뉴얼 내용 출력

</div>



## GitHub 와의 연계

```
git remote add origin https://github.com/kipid/Example_Repository.git
git push -u origin main
// Id 비번으로 인증. =&gt; GitHub 패스워드가 아닌 토큰(token)을 입력.

git commit -m "Message"
git push

git pull // remote repository 에 있는 commit 들 가져오기.
```/



### 다른 사람도 내 repository 에 git push 할 수 있게 만들기

상단의 여러 탭 중에서 Settings 탭을 클릭하세요. 그 다음 화면 왼쪽의 Manage access 탭을 클릭.

Invite a collaborator =&gt; Add ... to Example_Repository



## 다른 사람의 repository 내 컴퓨터로 가져오기

```
git clone https://github.com/numpy/numpy.git



git push -u origin main : 로컬 레포지토리의 내용을 처음으로 리모트 레포지토리에 올릴 때 사용합니다.(-u origin main 가 무슨 뜻인지는 'Git에서 브랜치 사용하기' 챕터에서 배울 거니까 걱정마세요!)
git push : 로컬 레포지토리의 내용을 리모트 레포지토리에 보내기
git pull : 리모트 레포지토리의 내용을 로컬 레포지토리로 가져오기
git clone [프로젝트의 GitHub 상 주소] : GitHub에 있는 프로젝트를 내 컴퓨터로 가져오기
```/



## Git history

```
git log

git log --pretty=oneline

git show commit-hash

git commit // 긴 commit message 를 남길 수 있음.

git commit --amend // 이전 commit 수정하기.
```/

<figure><div class="fig">
	<div class="caption">GitHub GUI (Graphical User Interface) 에서 git commit --amend 하기</div>
	<img src="https://blog.kakaocdn.net/dn/ZNyiz/btsISGQ6XCn/Ih9ilA3OUD6cA7Cwx6aqo1/img.png">
</div></figure>



## 커밋 메시지 작성 가이드라인

(1) 커밋 메시지의 제목과 상세 설명 사이에는 한 줄을 비워두세요.

(2) 커밋 메시지의 제목 뒤에 온점(.)을 붙이지 마세요.

(3) 커밋 메시지의 제목의 첫 번째 알파벳은 대문자로 작성하세요.

(4) 커밋 메시지의 제목은 명령조로 작성하세요.(Fix it / <s>Fixed it / Fixes it</s>)

(5) 커밋의 상세 내용에는 이런 걸 적으면 좋습니다.

<ul>
<li>왜 커밋을 했는지</li>
<li>어떤 문제가 있었고</li>
<li>적용한 해결책이 어떤 효과를 가지는지</li>
</ul>

(6) 다른 사람들이 자신의 코드를 바로 이해할 수 있다고 가정하지 말고 최대한 친절하게 작성하세요.



## 커밋할 때 알아야할 가이드라인

(1) 하나의 커밋에는 하나의 수정사항, 하나의 이슈(issue)를 해결한 내용만 남기도록 하세요. 다양하게 수정을 하고나서 하나의 커밋으로 남기는 것은 좋지 않습니다. 하나의 커밋이 하나의 사실만을 갖고 있어야 나중에 이해하기 쉽습니다.

(2) 현재 프로젝트 디렉토리의 상태가 그 내부의 전체 코드를 실행했을 때 에러가 발생하지 않는 상태인 경우에만 커밋을 하도록 하세요. 나중에 동료 개발자가 특정 커밋의 코드로 실행했을 때 에러가 발생한다면 혼란을 줄 수 있습니다.

<ul>
<li>나중에 다시 봤을 때 이해하는데 어려움이 없도록</li>
<li>다른 동료 개발자와 협업하는 데 방해가 되지 않도록</li>
</ul>



## 긴 커맨드에 alias 설정하기

```
git config alias.history 'log --pretty=oneline'
// git histroy 라고만 써도 자동으로 git log --pretty=oneline 을 실행하게 됩
```/


## 두 commit 간의 차이 보기

```
git diff [커밋 A의 아이디] [커밋 B의 아이디]
```/



## HEAD (이전 commit 으로 git reset 하기)

HEAD: 어떤 commit 하나를 가리킴.

```
git reset --hard [커밋 아이디] // 과거 commit 으로 아예 돌아가고 싶을 때 (꽤나 위험한 명령어. 뒷쪽 commit 들이 모두 날라감.)
git reset [option] HEAD^ // 이전 commit
git reset [option] HEAD~n // n번째 전 commit
```/

<figure><div class="fig">
	<div class="caption">GitHub 에서 git reset 하기. Revert changes in commit. GitHub 에선 reset 이후의 commit 들도 history 로 그대로 남아있긴 함. 덮어 씌우는게 아니라. 그래서 다시 돌아갈수도 있음.</div>
	<img src="https://blog.kakaocdn.net/dn/bAP42J/btsIP8IHcmV/KeqvfQVHoComKl1jnQIqQk/img.png">
</div></figure>



### git reset을 쓸 때 --hard는 뭐였을까?

```
git reset --hard [커밋 아이디]
git reset --soft [커밋 아이디]
git reset --mixed [커밋 아이디]
```/

<figure><div class="fig">
	<div class="caption">git reset [옵션] [Commit ID]</div>
	<img src="https://blog.kakaocdn.net/dn/cvCon0/btsISJmMTd6/JeOXJjkJwloP4XPkrzvZyK/img.png">
</div></figure>



### staging area 에 있던 것들은 커밋하고 나면 어떻게 될까?

커밋을 했다고 staging area 가 초기화되거나 하지는 않는 겁니다.

계속 git add 를 할 때마다 staging area 에서는 새로운 파일이 추가되거나 원래 있던 파일이 더 새로운 버전의 것으로 교체되거나 할 뿐입니다.

staging area 에 있던 것들은 커밋을 하더라도 그것과 상관없이 계속 남아있다는 점



## Commit 에 tag 달기

```
git tag [태그 이름] [커밋 아이디]

git tag // 프로젝트 디렉토리에 있는 모든 태그를 조회

git show [태그 이름] // 태그와 연결된 커밋이 보고 싶으면
```/

<figure><div class="fig">
	<div class="caption">GitHub GUI (Graphical User Interface) 에서 git tag 달기.</div>
	<img src="https://blog.kakaocdn.net/dn/tQxW5/btsISWlUsvR/HL1W3SbVKuCyKW9KN3hSqK/img.png">
</div></figure>



## Git commands 정리

<div class="bcf">

git log : 커밋 히스토리를 출력

git log --pretty=oneline : --pretty 옵션을 사용하면 커밋 히스토리를 다양한 방식으로 출력할 수 있습니다. --pretty 옵션에 oneline이라는 값을 주면 커밋 하나당 한 줄씩 출력해줍니다. --pretty 옵션에 대해 더 자세히 알고싶으면 이 링크를 참고하세요.

git show [커밋 아이디] : 특정 커밋에서 어떤 변경사항이 있었는지 확인

git commit --amend : 최신 커밋을 다시 수정해서 새로운 커밋으로 만듦

git config alias.[별명] [커맨드] : 길이가 긴 커맨드에 별명을 붙여서 이후로 별명으로 해당 커맨드를 실행할 수 있도록 설정

git diff [커밋 A의 아이디] [커밋 B의 아이디] : 두 커밋 간의 차이 비교

git reset [옵션] [커밋 아이디] : 옵션에 따라 하는 작업이 달라짐(옵션을 생략하면 --mixed 옵션이 적용됨)

<div class="cmt">

(1) HEAD가 특정 커밋을 가리키도록 이동시킴(--soft는 여기까지 수행)

(2) staging area도 특정 커밋처럼 리셋(--mixed는 여기까지 수행)

(3) working directory도 특정 커밋처럼 리셋(--hard는 여기까지 수행)

</div>

그리고 이때 커밋 아이디 대신 HEAD의 위치를 기준으로 한 표기법(예 : HEAD^, HEAD~3)을 사용해도 됨

git tag [태그 이름] [커밋 아이디] : 특정 커밋에 태그를 붙임

</div>



## Branch

Branch: 나뭇가지. 하나의 코드 관리 흐름.

master branch or main branch (요새는 main 으로 주로 이름 붙임.)

```
git branch premium // premium branch 만들기

git checkout premium // premium branch 로 이동



git branch // branch 조회



git branch -d test // delete branch



git checkout -b test // branch 생성 및 이동
git checkout main // main branch 로 이동
```/



### Branch merge 하기

```
git checkout premium
git merge main // 현재 premium branch 에 main branch merge 하기
```/



#### Merge conflict

1. Conflict 가 발생한 파일을 연다.

2. Merge 의 결과가 되었으면 하는 모습대로 코드를 수정.

3. Commit.

or

```
git merge --abort // Merge 취소
```/



#### 여러 파일에서 conflict 가 났을 때

파일 하나씩 conflict 를 해결하고 git add [파일 이름] 커맨드로 하나씩 staging area 에 올리거나(중간중간에 git status 커맨드로 현재 상태 확인하면서)

모든 파일들의 conflict 를 다 해결하고, git add . 커맨드로 한번에 staging area 에 올리고

커밋을 하면 됩니다.



### Remote Repository 의 브랜치는 이렇게 보입니다!

#### origin 이란?

```
git remote add origin https://github.com/kyuri-dev/Math_Box.git
git push -u origin main // -u 는 --set-upstream 이라는 옵션의 약자
```/

Git 에서는 리모트 레포지토리를 최초로 추가할 때 origin 이라는 이름으로 가리키는 것이 관례화되어 있습니다.

origin 은 '근원', '기원' 이라는 뜻을 가집니다. 아마도 다른 사람의 리모트 레포지토리를 자신의 컴퓨터로 가져와서 작업을 하는 사람의 입장에서는 리모트 레포지토리가 프로젝트의 근원이 되는 존재이기 때문에 그런 관습이 생긴 것으로 추측됩니다.



#### Remote Repositoy 에 있는 브랜치

```
git push origin main:main // origin 은 리모트 레포지토리를 나타내고, main:main 에서 더 먼저 나오는 main 는 로컬 레포지토리의 main 브랜치(~에서)/더 뒤에 나오는 main 는 리모트 레포지토리의 main 브랜치(~으로)를 나타냅니다.
```/

그냥 처음부터 tracking connection 을 설정하고 그 이후부터는 git push, git pull 이라고만 써서 편하게 푸시와 풀을 하는 게 좋겠죠? 이게 바로 제가 맨 처음에 로컬 레포지토리의 내용을 리모트 레포지토리로 보낼 때 -u 라는 옵션을 썼던 이유입니다.

```
git push -u origin main // tracking connection 설정
```/



#### origin/main 의 의미

git push 를 해준 적이 없다면, Local repository 의 main branch 가 나타내는 commit 들과 origin/main 인 remote repository 의 main branch 를 나타내는 commit 이 다를 수 있음.

git push 로 통합시킬 수 있음.



#### Remote repository 에 새로운 branch 추가하기

```
git checkout premium
git push --set-upstream origin premium // premium branch 를 remote 로 처음 push 할 때
```/



## HEAD 와 Branch 의 관계

Branch 는 코드를 관리하는 하나의 흐름.

Branch 는 Commit 을 가리키는 포인터.

HEAD 는 branch 를 가리킴.

Merge commit: 두 branch 가 하나로 합쳐짐. 합쳐진 branch 를 HEAD 가 가리킴.

git reset 커맨드를 사용하면

<ol>
<li>HEAD는 여전히 같은 브랜치를 가리키고,</li>
<li>HEAD가 가리키는 브랜치가 다른 특정 커밋을 가리키게 됩니다.</li>
<li>이 때문에 결국 HEAD가 간접적으로 가리키던 커밋도 바뀌게 되는 겁니다.</li>
</ol>

git reset에 관해서 분명하게 아셔야할 게

<ol>
<li>과거의 커밋으로 git reset을 한다고 그 이후의 커밋들이 삭제되는 게 절대 아닙니다. 계속 남아있습니다.</li>
<li>git reset은 과거의 커밋뿐만 아니라 현재 HEAD가 가리키는 커밋 이후의 커밋으로도 할 수 있습니다.</li>
</ol>



### Detached HEAD

브랜치를 통해서 커밋을 가리키는 게 아니라 본인이 직접 커밋을 가리키고 있는 상태의 HEAD를 특별히 가리키는 말.

```
git checkout [Commit ID]
```/

Detached 는 우리말로 ‘~로부터 떨어진, 분리된’이라는 뜻을 갖는데요. 브랜치로부터 떨어진 상태이기 때문에 이렇게 부르는 겁니다.



<div class="bcf">

git checkout 커맨드로는 HEAD 가 직접적으로 가리키는 것을 바꿀 수 있고

git checkout 뒤에는 커밋 아이디 또는 브랜치의 이름을 줘서

HEAD 가 직접 커밋을 가리키거나, 브랜치를 가리키도록 할 수 있다는 뜻입니다.

</div>



<div class="bcf">

git reset: HEAD 가 가리키던 브랜치가 다른 커밋을 가리키도록 한다. HEAD 도 결국 간접적으로 다른 커밋을 가리키게되는 효과가 생긴다

git checkout: HEAD 자체가 다른 커밋이나 브랜치를 가리키도록 한다. 브랜치를 통하지 않고, 커밋을 직접적으로 가리키는 HEAD 를 Detached HEAD 라고 한다

</div>



## Merge commit

### 3-way merge

Merge 를 하면 새로운 commit 이 생긴다. 이를 Merge commit 이라고 부른다.

<figure><div class="fig">
	<div class="caption">3-way merge</div>
	<img src="https://blog.kakaocdn.net/dn/qIxJh/btsIQMdT5yq/GpKTzwCG2j6ZdaF4Kp4Pd1/img.png">
</div></figure>



case1

<div class="bcf">
지금 base 가 A이고, main 는 A, premium 은 B죠? 그럼 base 를 기준으로 볼 때, main 에서는 변화가 없었지만, premium 에서는 A 가 B 로 변경된 상태입니다. 3-way merge 는 base 에서 변화가 발생한 것을 우선 채택합니다. 그래서 머지 결과는 'B' 가 됩니다.
</div>



case2

<div class="bcf">
지금 base 가 1이고, main 는 2, premium 은 1이죠? 이 경우에도 base 에서 변화가 발생한 2가 머지 결과가 됩니다.
</div>



case3

<div class="bcf">
지금 base 가 "hello" 이고, main 는 "hello" 를 삭제한 공백 상태, premium 은 "hello" 입니다. "hello" 를 삭제해서 공백 상태가 된 것이 변화가 더 발생한 것이기 때문에 머지 결과는 공백이 됩니다.
</div>



case4

<div class="bcf">
지금 base 가 "bye", main 가 "fighting", premium 이 "please" 인데요. 지금은 이전 경우들과 좀 다르네요. 둘 다 base 때와는 다른 변화가 일어났는데요. 이렇게 두 브랜치에서 다 변화가 있을 때 Git 은 어떤 변화를 선택해야할까요? 정답은 바로 <strong>'Git도 모른다!'</strong> 입니다. 사실, 바로 이런 경우에 여러분이 배운 Conflict 가 발생합니다. 이전에 Conflict 가 발생했을 때 그것을 해결하고 머지를 마무리했던 거 기억나시죠? 바로 이런 경우였던 겁니다.
</div>



종합 정리

<div class="bcf">

base때의 내용과 비교했을 때 달라진 부분이 있는 것이 우선시되고,

두 브랜치에서 둘다 변화가 일어났을 때는 Conflict를 발생시켜서 사용자가 스스로 선택하게끔 한다는 걸 기억하시면 됩니다.

</div>



### Merge commit 이 안생기는 경우: Fast-forward merge

커밋 히스토리에서 같은 선 (line) 상에 있는 브랜치를 머지할 때 Fast-forward 머지가 이루어집니다.



## Git commands 정리

<div class="bcf">

git branch [새 브랜치 이름]: 새로운 브랜치를 생성

git checkout -b [새 브랜치 이름]: 새로운 브랜치를 생성하고 그 브랜치로 바로 이동

git branch -d [기존 브랜치 이름]: 브랜치 삭제

git checkout [기존 브랜치 이름]: 그 브랜치로 이동

git merge [기존 브랜치 이름]: 현재 브랜치에 다른 브랜치를 머지

git merge --abort: 머지를 하다가 conflict가 발생했을 때, 일단은 머지 작업을 취소하고 이전 상태로 돌아감

</div>



## git pull (or fetch)

git push 를 하기 전에 보통 git pull (or fetch) 을 먼저 해야한다.

이 경우 conflict 가 나는 경우가 많을텐데, 이런 conflict 를 잘 해결한 뒤 git commit 을 해야한다.

<div class="bcf">
<strong>git pull = git fetch + git merge</strong>
</div>


### git fetch

우선 commit 들을 merge 없이 가져오는 명령어.

Remote repository 에서 가져온 branch 의 내용을 merge 하기 전에 점검해야할 필요가 있을 때 사용.

Remote repository 에 있는 branch 의 내용과 내가 작성한 코드를 비교해서 잘못된 부분이 없는지 검토해야 할 때.

```
git fetch

git diff premium origin/premium // 두 local branch 와 remote branch 를 비교
```/



## git blame [filename]

file 의 각 부분이 어떤 commit 으로 수정되었는지 보여주는 명령어.

(이건 GitHub GUI (Graphical User Interface) 에서 잘 못봤던거 같은데, 찾아봐야겠음.)



### git show [commit id]

commit 의 내용 (file 의 변화된 부분, commit message 등) 보여주기



## git revert [commit id]

Commit 을 되돌리는 명령어. Commit 이 하나 더 만들어짐 (Revert commit).

이후 commit 들을 아예 지워버리는 git reset 보다 더 많이 활용될듯.



### git revert [복귀 될 commit id]..[초기화 할 commit 들 중 가장 나중 commit id] // (여러개 commit 들을 한꺼번에 revert 하기)

```
git revert [복귀 될 commit id]..[초기화 할 commit 들 중 가장 나중 commit id] // 여러개의 revert commit 들이 생김
```/



## RRA

<ol class="refs">
<li id="ref-codeit-git"><a target="_blank" href="https://www.codeit.kr/topics/git">Git - GIT 강의 | 코드잇</a><br/>
	<a target="_blank" href="https://www.codeit.kr/topics/collaborating-with-git">Git 협업하기 - 강의 | 코드잇</a></li>
<li id="ref-git-download"><a target="_blank" href="https://git-scm.com/">https://git-scm.com/</a></li>
</ol>
</codeprint><!-- SEE -->

<codeprint id="docuK-script">
<script>
(function(m, $, undefined) {
m.printMode=false;
m.recoCats="[IT/Programming]--국비 지원 코딩/공부";
m.wait=1024;
m.delayPad=512;

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
**/
window.disqus_config=function () {
	this.page.identifier="Git-을-배워보자-Feat-GitHub"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
	this.page.url=`https://kipid.tistory.com/entry/${this.page.identifier}`; // Replace PAGE_URL with your page's canonical URL variable
};
})(window.m, jQuery);
</script>

<!-- From kipid.tistory CDN -->
<script src="https://tistory3.daumcdn.net/tistory/1468360/skin/images/docuK-postProcess-2.3.js" charset="utf-8"></script>
</codeprint><!-- docuK-script -->
